
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>vue.js</title>
        <meta charset="utf-8">
        <meta name="description" content="Vue.js - Intuitive, Fast and Composable MVVM for building interactive interfaces.">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

        <meta property="og:type" content="article">
        <meta property="og:title" content="vue.js">
        <meta property="og:description" content="Vue.js - Intuitive, Fast and Composable MVVM for building interactive interfaces.">
        <meta property="og:image" content="https://vuejs.org/images/logo.png">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="vue.js">
        <meta name="twitter:description" content="Vue.js - Intuitive, Fast and Composable MVVM for building interactive interfaces.">
        <meta name="twitter:image" content="https://vuejs.org/images/logo.png">

        <link rel="icon" href="/images/logo.png" type="image/x-icon">

        <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Dosis:500&text=Vue.js' rel='stylesheet' type='text/css'>

        <!-- main page styles -->
        <link rel="stylesheet" href="/css/page.css">

        <!-- this needs to be loaded before guide's inline scripts -->
        <script src="/js/vue.js"></script>
        <script>window.PAGE_TYPE = "api"</script>
    </head>
    <body class="docs">        <div id="mobile-bar" >
            <a class="menu-button"></a>
            <a class="logo" href="/"></a>
        </div>
        <div id="header">
  <a id="logo" href="/">
    <img src="/images/logo.png">
    <span>Vue.js</span>
  </a>
  <ul id="nav">
    <li>
  <form id="search-form">
    <input type="text" id="search-query-nav" class="search-query st-default-search-input">
  </form>
</li>
<li><a href="/v2/guide/" class="nav-link">가이드</a></li>
<li><a href="/v2/api/" class="nav-link current">API</a></li>
<li><a href="/v2/examples/" class="nav-link">예제</a></li>
<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">생태계</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>도움</h4></li>
    <li><ul>
      <li><a href="http://forum.vuejs.org" class="nav-link" target="_blank">포럼</a></li>
      <li><a href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">채팅</a></li>
      <li><a href="https://github.com/vuejs-templates" class="nav-link" target="_blank">템플릿</a></li>
    </ul></li>
    <li><h4>뉴스</h4></li>
    <li><ul>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">블로그</a></li>
      <li><a href="https://vuejsjob.com/?ref=vuejs" class="nav-link" target="_blank">구인구직</a></li>
    </ul></li>
    <li><h4>Core 플러그인</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
    </ul></li>
    <li><h4>리소스 목록</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">공식 저장소</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Awesome Vue</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">다른 언어로 보기</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://vuejs.org/" class="nav-link" target="_blank">영어</a></li>
    <li><a href="https://cn.vuejs.org/" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://jp.vuejs.org/" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://ru.vuejs.org/" class="nav-link" target="_blank">Русский</a></li>
  </ul>
</li>


  </ul>
</div>

        
            <div id="main" class="fix-sidebar">
                
                    
    <div class="sidebar">
    <ul class="main-menu">
        <li>
  <form id="search-form">
    <input type="text" id="search-query-sidebar" class="search-query st-default-search-input">
  </form>
</li>
<li><a href="/v2/guide/" class="nav-link">가이드</a></li>
<li><a href="/v2/api/" class="nav-link current">API</a></li>
<li><a href="/v2/examples/" class="nav-link">예제</a></li>
<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">생태계</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>도움</h4></li>
    <li><ul>
      <li><a href="http://forum.vuejs.org" class="nav-link" target="_blank">포럼</a></li>
      <li><a href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">채팅</a></li>
      <li><a href="https://github.com/vuejs-templates" class="nav-link" target="_blank">템플릿</a></li>
    </ul></li>
    <li><h4>뉴스</h4></li>
    <li><ul>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">블로그</a></li>
      <li><a href="https://vuejsjob.com/?ref=vuejs" class="nav-link" target="_blank">구인구직</a></li>
    </ul></li>
    <li><h4>Core 플러그인</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
    </ul></li>
    <li><h4>리소스 목록</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">공식 저장소</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Awesome Vue</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">다른 언어로 보기</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://vuejs.org/" class="nav-link" target="_blank">영어</a></li>
    <li><a href="https://cn.vuejs.org/" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://jp.vuejs.org/" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://ru.vuejs.org/" class="nav-link" target="_blank">Русский</a></li>
  </ul>
</li>


    </ul>
    <div class="list">
        <div class="main-sponsor">
            <span>지원을 받고 있습니다.</span><br>
            <a href="http://www.thedifferenceengine.io/" target="_blank"
                style="background-color: #f3f3f3; padding: 10px 0">
                <img src="/images/tde.png">
            </a>
        </div>
        <a class="become-backer" href="/support-vuejs">
            후원하기
        </a>
        <h2>
            
              API
            
            
                <select class="version-select">
                    <option value="SELF" selected>2.0</option>
                    <option value="v1">1.0</option>
                    <option value="012">0.12</option>
                    <option value="011">0.11</option>
                </select>
            
        </h2>
        <ul class="menu-root">
            
            
        </ul>
    </div>
</div>


<div class="content api with-sidebar ">
    
      <div id="ad">
  <!-- <span>Sponsored By</span><br>
  <a href="http://www.thedifferenceengine.io/" target="_blank"
    style="background-color: rgba(0,0,0,.85); padding: 10px 0">
    <img src="/images/tde.png">
  </a> -->
  <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=vuejs" id="_carbonads_js"></script>
</div>

    
    
    <h2 id="전역-설정"><a href="#전역-설정" class="headerlink" title="전역 설정"></a>전역 설정</h2><p><code>Vue.config</code> 은 Vue의 전역 설정을 가지고 있는 객체입니다. 앱이 실행하기 전에 아래의 속성들을 변경할 수 있습니다:</p>
<h3 id="silent"><a href="#silent" class="headerlink" title="silent"></a>silent</h3><ul>
<li><p><strong>타입:</strong> <code>boolean</code></p>
</li>
<li><p><strong>기본값:</strong> <code>false</code></p>
</li>
<li><p><strong>사용방법:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.config.silent = <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>모든 Vue의 로그와 경고를 출력하지 않습니다.</p>
</li>
</ul>
<h3 id="optionMergeStrategies"><a href="#optionMergeStrategies" class="headerlink" title="optionMergeStrategies"></a>optionMergeStrategies</h3><ul>
<li><p><strong>타입:</strong> <code>{ [key: string]: Function }</code></p>
</li>
<li><p><strong>기본값:</strong> <code>{}</code></p>
</li>
<li><p><strong>사용방법:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.config.optionMergeStrategies._my_option = <span class="function"><span class="keyword">function</span> (<span class="params">parent, child, vm</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> child + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Profile = Vue.extend(&#123;</div><div class="line">  <span class="attr">_my_option</span>: <span class="number">1</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// Profile.options._my_option = 2</span></div></pre></td></tr></table></figure>
<p>사용자 정의 병합 전략을 설정할 수 있습니다.</p>
<p>병합 전략은 부모 및 자식 인스턴스에 정의된 해당 옵션의 값을 첫번째와 두번째 인자로 전달 받습니다. 컨텍스트 Vue 객체는 세번째 인자로 전달 받습니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/mixins.html#Custom-Option-Merge-Strategies">사용자 정의 병합 전략</a></p>
</li>
</ul>
<h3 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h3><ul>
<li><p><strong>타입:</strong> <code>boolean</code></p>
</li>
<li><p><strong>기본값:</strong> <code>true</code> (<code>false</code> in production builds)</p>
</li>
<li><p><strong>사용방법:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Vue를 불러온 후 동기적으로 설정됩니다</span></div><div class="line">Vue.config.devtools = <span class="literal">true</span></div></pre></td></tr></table></figure>
<p><a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="external">vue-devtools</a>를 사용할 수 있게 합니다. 개발용 빌드시 <code>true</code>, 배포용 빌드는 <code>false</code>가 기본 값입니다. <code>true</code>로 설정하면 통해 배포용 빌드에서 사용할 수 있습니다.</p>
</li>
</ul>
<h3 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>기본값:</strong> 오류 발생 시점의 오류</p>
</li>
<li><p><strong>사용방법:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.config.errorHandler = <span class="function"><span class="keyword">function</span> (<span class="params">err, vm</span>) </span>&#123;</div><div class="line">  <span class="comment">// 오류 처리</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>컴포넌트 렌더링 또는 감시자에 catch 되지 않은 오류에 대한 핸들러를 할당합니다. 핸들러는 오류와 Vue 인스턴스와 함께 호출됩니다.</p>
<blockquote>
<p>오류 추적 서비스인 <a href="https://sentry.io" target="_blank" rel="external">Sentry</a>에서 <a href="https://sentry.io/for/vue/" target="_blank" rel="external">공식 사용 설명서</a> 를 제공합니다.</p>
</blockquote>
</li>
</ul>
<h3 id="ignoredElements"><a href="#ignoredElements" class="headerlink" title="ignoredElements"></a>ignoredElements</h3><ul>
<li><p><strong>타입:</strong> <code>Array&lt;string&gt;</code></p>
</li>
<li><p><strong>기본값:</strong> <code>[]</code></p>
</li>
<li><p><strong>사용방법:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.config.ignoredElements = [</div><div class="line">  <span class="string">'my-custom-web-component'</span>, <span class="string">'another-web-component'</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>Vue가 외부에서 정의된 사용자 정의 엘리먼트(예를 들어, Web Components API)를 무시하도록 합니다. 전역 컴포넌트를 등록하지 않았거나, <code>알수 없는 사용자 정의 엘리먼트</code>에 대한 경고를 표시합니다.</p>
</li>
</ul>
<h3 id="keyCodes"><a href="#keyCodes" class="headerlink" title="keyCodes"></a>keyCodes</h3><ul>
<li><p><strong>타입:</strong> <code>{ [key: string]: number | Array&lt;number&gt; }</code></p>
</li>
<li><p><strong>기본값:</strong> <code>{}</code></p>
</li>
<li><p><strong>사용방법:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.config.keyCodes = &#123;</div><div class="line">  <span class="attr">v</span>: <span class="number">86</span>,</div><div class="line">  <span class="attr">f1</span>: <span class="number">112</span>,</div><div class="line">  <span class="attr">mediaPlayPause</span>: <span class="number">179</span>,</div><div class="line">  <span class="attr">up</span>: [<span class="number">38</span>, <span class="number">87</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>v-on에 사용자 정의 키를 할당합니다.</p>
</li>
</ul>
<h2 id="전역-API"><a href="#전역-API" class="headerlink" title="전역 API"></a>전역 API</h2><h3 id="Vue-extend">Vue.extend( options )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{Object} options</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>Vue 생성자의 “하위 클래스”를 만듭니다. 전달인자는 컴포넌트 옵션을 포함하는 객체이어야 합니다.</p>
<p>특별히 중요해야 할 경우는 <code>data</code> 옵션입니다. <code>Vue.extend()</code>와 함께 사용하는 경우 반드시 함수여야 합니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mount-point"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 생성자를 만듭니다.</span></div><div class="line"><span class="keyword">var</span> Profile = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,</div><div class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">firstName</span>: <span class="string">'Walter'</span>,</div><div class="line">      <span class="attr">lastName</span>: <span class="string">'White'</span>,</div><div class="line">      <span class="attr">alias</span>: <span class="string">'Heisenberg'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// Profile 인스턴스를 만들고, 엘리먼트에 마운트 합니다.</span></div><div class="line"><span class="keyword">new</span> Profile().$mount(<span class="string">'#mount-point'</span>)</div></pre></td></tr></table></figure>
<p>아래처럼 출력됩니다:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Walter White aka Heisenberg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/components.html">컴포넌트</a></p>
</li>
</ul>
<h3 id="Vue-nextTick">Vue.nextTick( [callback, context] )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{Function} [callback]</code></li>
<li><code>{Object} [context]</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>다음 DOM 업데이트 사이클 이후 실행하는 콜백을 연기합니다. DOM 업데이트를 기다리기 위해 일부 데이터를 변경한 직후 사용해야 합니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 데이터를 변경합니다</span></div><div class="line">vm.msg = <span class="string">'Hello'</span></div><div class="line"><span class="comment">// 아직 DOM 업데이트가 되지 않았습니다</span></div><div class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// DOM이 업데이트 되었습니다</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>2.1.0에 새로 생겼습니다: 콜백이 없고, Promise를 지원하는 환경에서 Promise를 반환합니다.</p>
</blockquote>
</li>
<li><p><strong>참고:</strong> <a href="../guide/reactivity.html#Async-Update-Queue">비동기 갱신 큐</a></p>
</li>
</ul>
<h3 id="Vue-set">Vue.set( object, key, value )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{Object} object</code></li>
<li><code>{string} key</code></li>
<li><code>{any} value</code></li>
</ul>
</li>
<li><p><strong>반환 값:</strong> 설정한 값.</p>
</li>
<li><p><strong>사용방법:</strong></p>
<p>객체에 대한 속성을 설정합니다. 객체가 반응형이면, 속성이 반응형 속성으로 만들어지고 뷰 업데이트를 발생시킵니다.<br>이는 Vue가 속성 추가를 감지하지 못하는 한계를 넘기 위해 사용합니다</p>
<p><strong>객체는 Vue 인스턴스 또는 Vue 인스턴스의 루트 객체일 수 없습니다.</strong></p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/reactivity.html">반응형에 대해 깊이 알기</a></p>
</li>
</ul>
<h3 id="Vue-delete">Vue.delete( object, key )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{Object} object</code></li>
<li><code>{string} key</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>객체의 속성을 삭제합니다. 객체가 반응형이면, 뷰 업데이트를 발생시킵니다. 주로 Vue가 속성 삭제를 감지하지 못하는 한계를 극복하기 위해 사용하지만 거의 사용하지 않아야 합니다.<br><strong> 객체는 Vue 인스턴스 또는 Vue 인스턴스의 루트 데이터 객체일 수 없습니다. </strong></p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/reactivity.html">반응형에 대해 깊이 알기</a></p>
</li>
</ul>
<h3 id="Vue-directive">Vue.directive( id, [definition] )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function | Object} [definition]</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>전역 지시문을 등록하거나 검색합니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 등록</span></div><div class="line">Vue.directive(<span class="string">'my-directive'</span>, &#123;</div><div class="line">  <span class="attr">bind</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="attr">inserted</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="attr">update</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="attr">componentUpdated</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="attr">unbind</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 등록 (간단한 함수 지시문)</span></div><div class="line">Vue.directive(<span class="string">'my-directive'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// `bind`와 `update`를 호출합니다.</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// getter, 등록된 지시어의 경우 반환합니다.</span></div><div class="line"><span class="keyword">var</span> myDirective = Vue.directive(<span class="string">'my-directive'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/custom-directive.html">사용자 정의 지시문</a></p>
</li>
</ul>
<h3 id="Vue-filter">Vue.filter( id, [definition] )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function} [definition]</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>전역 필터를 등록하거나 검색합니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 등록</span></div><div class="line">Vue.filter(<span class="string">'my-filter'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="comment">// 처리된 값을 반환합니다</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// getter, 필터가 등록된 경우 반환합니다</span></div><div class="line"><span class="keyword">var</span> myFilter = Vue.filter(<span class="string">'my-filter'</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Vue-component">Vue.component( id, [definition] )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function | Object} [definition]</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>전역 컴포넌트를 등록하거나 검색합니다. 등록 시 자동으로 컴포넌트의 <code>name</code>을 주어진 <code>id</code>로 설정합니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 확장된 생성자를 등록합니다</span></div><div class="line">Vue.component(<span class="string">'my-component'</span>, Vue.extend(&#123; <span class="comment">/* ... */</span> &#125;))</div><div class="line"></div><div class="line"><span class="comment">// 옵션 객체를 등록합니다 (자동으로 Vue.extend를 호출합니다)</span></div><div class="line">Vue.component(<span class="string">'my-component'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 등록된 컴포넌트를 검색합니다 (항상 생성자를 반환합니다)</span></div><div class="line"><span class="keyword">var</span> MyComponent = Vue.component(<span class="string">'my-component'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/components.html">컴포넌트</a></p>
</li>
</ul>
<h3 id="Vue-use">Vue.use( plugin )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{Object | Function} plugin</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>Vue.js 플러그인을 설치합니다. 플러그인이 Object인 경우 <code>install</code> 메소드를 가져야 합니다. 플러그인이 함수 그 자체이면 install 메소드로 처리됩니다. install 메소드는 Vue를 인자로 사용해 호출합니다.</p>
<p>이 메소드가 동일한 플러그인에서 여러번 호출되면 한번만 설치합니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/plugins.html">플러그인</a></p>
</li>
</ul>
<h3 id="Vue-mixin">Vue.mixin( mixin )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{Object} mixin</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>전역으로 mixin을 적용합니다. 생성된 모든 Vue 인스턴스에 영향을 줍니다. 플러그인 작성자가 컴포넌트에 사용자 정의 동작을 주입하는데 플러그인을 사용할 수 있습니다. <strong>애플리케이션 코드</strong>에서는 추천하지 않습니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/mixins.html#Global-Mixin">전역 Mixins</a></p>
</li>
</ul>
<h3 id="Vue-compile">Vue.compile( template )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{string} template</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>템플릿 문자열을 렌더링 함수로 컴파일합니다. <strong>독립 실행형 빌드에서만 가능합니다.</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> res = Vue.compile(<span class="string">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">msg</span>: <span class="string">'hello'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">render</span>: res.render,</div><div class="line">  <span class="attr">staticRenderFns</span>: res.staticRenderFns</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/render-function.html">렌더 함수</a></p>
</li>
</ul>
<h2 id="옵션-데이터"><a href="#옵션-데이터" class="headerlink" title="옵션 / 데이터"></a>옵션 / 데이터</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><ul>
<li><p><strong>타입:</strong> <code>Object | Function</code></p>
</li>
<li><p><strong>제한:</strong> 컴포넌트에서 사용될 때만 <code>함수</code>를 승인합니다.</p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스의 데이터 객체입니다. Vue는 속성을 getter/setter로 재귀적으로 변환해 “반응형”으로 만듭니다. <strong>객체는 반드시 기본 객체이어야 합니다</strong>: 브라우저 API 객체 및 프로토타입 속성과 같은 기본 객체는 무시됩니다. 데이터는 데이터일 뿐이며 객체 자체의 상태를 유지하는 동작은 관찰하지 않는 것이 좋습니다.</p>
<p>일단 관찰되어지면, 루트 데이터 객체에 반응형 속성을 추가할 수 없습니다. 따라서 인스턴스 생성 이전에 모든 루트 수준의 반응형 속성을 미리 선언해야 합니다.</p>
<p>인스턴스가 생성된 이후 원래 데이터 객체는 <code>vm.$data</code>로 접근할 수 있습니다. Vue 인스턴스는 데이터 객체에 있는 모든 속성을 프록시하므로 <code>vm.a</code>는 <code>vm.$data.a</code>와 동일합니다.</p>
<p><code>_</code> 또는 <code>$</code>로 시작하는 속성은 Vue의 내부 속성 및 API 메소드와 충돌할 수 있으므로 Vue 인스턴스에서 <strong>프록시 되지 않습니다</strong>. <code>vm.$data._property</code>로 접근 해야 합니다.</p>
<p>필요한 경우, <code>vm.$data</code>를 <code>JSON.parse(JSON.stringify(...))</code>를 통해 전달함으로써 원본 객체의 복사본을 얻을 수 있습니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 직접 객체 생성</span></div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: data</div><div class="line">&#125;)</div><div class="line">vm.a <span class="comment">// -&gt; 1</span></div><div class="line">vm.$data === data <span class="comment">// -&gt; true</span></div><div class="line"></div><div class="line"><span class="comment">// Vue.extend()에서 반드시 함수를 사용해야 합니다.</span></div><div class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</div><div class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p class="tip"><strong>화살표 함수를 <code>data</code>에서 사용하면 안됩니다</strong> (예를 들어, <code>data: () =&gt; { return { a: this.myProp }}</code>) 화살표 함수가 부모 컨텍스트를 바인딩하기 때문에 <code>this</code>는 예상과 달리 Vue 인스턴스가 아니며, <code>this.myProp</code>는 정의되지 않습니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/reactivity.html">반응형에 대해 깊이 알기</a></p>
</li>
</ul>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><ul>
<li><p><strong>타입:</strong> <code>Array&lt;string&gt; | Object</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>부모 컴포넌트의 데이터를 받을 수 있게 노출된 속성의 리스트/해시 입니다. 단순한 배열 기반 구문과 사용자 지정 유효성 검사 및 기본값과 같은 고급 구성을 허용하는 Object 기반 구문이 있습니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 단순한 구문</span></div><div class="line">Vue.component(<span class="string">'props-demo-simple'</span>, &#123;</div><div class="line">  <span class="attr">props</span>: [<span class="string">'size'</span>, <span class="string">'myMessage'</span>]</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 유효성 검사를 포함한 객체 구문</span></div><div class="line">Vue.component(<span class="string">'props-demo-advanced'</span>, &#123;</div><div class="line">  <span class="attr">props</span>: &#123;</div><div class="line">    <span class="comment">// 타입 체크만 합니다.</span></div><div class="line">    height: <span class="built_in">Number</span>,</div><div class="line">    <span class="comment">// 타입 체크와 유효성 검사를 합니다.</span></div><div class="line">    age: &#123;</div><div class="line">      <span class="attr">type</span>: <span class="built_in">Number</span>,</div><div class="line">      <span class="attr">default</span>: <span class="number">0</span>,</div><div class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</div><div class="line">      <span class="attr">validator</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value &gt;= <span class="number">0</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/components.html#Props">Props</a></p>
</li>
</ul>
<h3 id="propsData"><a href="#propsData" class="headerlink" title="propsData"></a>propsData</h3><ul>
<li><p><strong>타입:</strong> <code>{ [key: string]: any }</code></p>
</li>
<li><p><strong>제한:</strong> <code>new</code>를 이용한 인스턴스 생성때만 사용됩니다.</p>
</li>
<li><p><strong>상세:</strong></p>
<p>인스턴스를 생성하는 동안 속성을 전달합니다. 이것은 단위 테스트를 쉽게 하기 위한 것 입니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Comp = Vue.extend(&#123;</div><div class="line">  <span class="attr">props</span>: [<span class="string">'msg'</span>],</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Comp(&#123;</div><div class="line">  <span class="attr">propsData</span>: &#123;</div><div class="line">    <span class="attr">msg</span>: <span class="string">'hello'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><ul>
<li><p><strong>타입:</strong> <code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스에 추가되는 계산된 속성입니다. 모든 getter와 setter는 자동으로 <code>this</code> 컨텍스트를 Vue 인스턴스에 바인딩 합니다.</p>
<p class="tip"><strong>계산된 속성을 정의 할 때 화살표 함수를 사용하면 안됩니다.</strong> 화살표 함수가 부모 컨텍스트를 바인딩하기 때문에 <code>this</code>는 Vue 인스턴스가 아니며 <code>this.a</code>는 정의되지 않습니다.</p>

<p>계산된 속성은 캐시되며, 반응형 종속성이 변경될 때 다시 계산됩니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  <span class="attr">computed</span>: &#123;</div><div class="line">    <span class="comment">// get만 가능합니다. 함수가 필요합니다.</span></div><div class="line">    aDouble: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// get과 set 입니다.</span></div><div class="line">    aPlus: &#123;</div><div class="line">      <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.a = v - <span class="number">1</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">vm.aPlus   <span class="comment">// -&gt; 2</span></div><div class="line">vm.aPlus = <span class="number">3</span></div><div class="line">vm.a       <span class="comment">// -&gt; 2</span></div><div class="line">vm.aDouble <span class="comment">// -&gt; 4</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/computed.html">계산된 속성</a></li>
</ul>
</li>
</ul>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><ul>
<li><p><strong>타입:</strong> <code>{ [key: string]: Function }</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스에 추가할 메소드입니다. VM 인스턴스를 통해 직접 접근하거나 지시문 표현식에서 사용할 수 있습니다. 모든 메소드는 자동으로 <code>this</code> 컨텍스트를 Vue 인스턴스에 바인딩합니다.</p>
<p class="tip"><strong>화살표 함수를 메소드를 정의하는데 사용하면 안됩니다.</strong> 화살표 함수가 부모 컨텍스트를 바인딩하기 때문에 <code>this</code>는 Vue 인스턴스가 아니며 <code>this.a</code>는 정의되지 않습니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    <span class="attr">plus</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.a++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">vm.plus()</div><div class="line">vm.a <span class="comment">// 2</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/events.html">메소드와 이벤트 핸들링</a></p>
</li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul>
<li><p><strong>타입:</strong> <code>{ [key: string]: string | Function | Object }</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>키가 표시되는 표현식이고 값이 콜백입니다. 값은 메서드 이름이 문자열이거나 추가 옵션이 포함된 Object가 될 수도 있습니다. Vue 인스턴스는 인스턴스 생성시 객체의 각 항목에 대해 <code>$watch()</code>를 호출합니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">c</span>: <span class="number">3</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">watch</span>: &#123;</div><div class="line">    <span class="attr">a</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'new: %s, old: %s'</span>, val, oldVal)</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 문자열 메소드 이름</span></div><div class="line">    b: <span class="string">'someMethod'</span>,</div><div class="line">    <span class="comment">// 깊은 감시자</span></div><div class="line">    c: &#123;</div><div class="line">      <span class="attr">handler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">      <span class="attr">deep</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">vm.a = <span class="number">2</span> <span class="comment">// -&gt; new: 2, old: 1</span></div></pre></td></tr></table></figure>
<p class="tip"><strong>화살표 함수를 감시자에 사용하면 안됩니다.</strong> (예를 들어, <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>) 화살표 함수가 부모 컨텍스트를 바인딩하기 때문에 <code>this</code>는 Vue 인스턴스가 아니며 <code>this.updateAutocomplete</code>는 정의되지 않습니다. </p>
</li>
<li><p><strong>참고:</strong> <a href="#vm-watch">인스턴스 메소드 - vm.$watch</a></p>
</li>
</ul>
<h2 id="옵션들-DOM"><a href="#옵션들-DOM" class="headerlink" title="옵션들 / DOM"></a>옵션들 / DOM</h2><h3 id="el"><a href="#el" class="headerlink" title="el"></a>el</h3><ul>
<li><p><strong>타입:</strong> <code>string | HTMLElement</code></p>
</li>
<li><p><strong>제한:</strong> <code>new</code>를 이용한 인스턴스 생성때만 사용됩니다.</p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스에 마운트 할 기존 DOM 엘리먼트 필요합니다. CSS 선택자 문자열 또는 실제 HTMLElement 이어야 합니다.</p>
<p>인스턴스가 마운트 된 이후, 그 엘리먼트는 <code>vm.$el</code>로 액세스 할 수 있습니다.</p>
<p>인스턴스화 할 때 옵션을 사용할 수 있는 경우 인스턴스는 즉시 컴파일을 시작합니다. 그렇지 않으면 컴파일을 수동으로 하기 위해 <code>vm.$mount()</code>를 명시적으로 호출해야합니다.</p>
<p class="tip">제공된 엘리먼트는 설치 지점으로 사용합니다. Vue 1.x와 달리 마운트 된 엘리먼트는 모든 경우에 Vue가 생성한 DOM으로 대체됩니다. 그러므로 루트 인스턴스를 <code>&lt;html&gt;</code> 또는 <code>&lt;body&gt;</code>에 마운트 하는 것을 권장하지 않습니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></p>
</li>
</ul>
<h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><ul>
<li><p><strong>타입:</strong> <code>string</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스의 마크업으로 사용할 문자열 템플릿 입니다. 템플릿은 마운트 된 엘리먼트를 <strong>대체</strong> 합니다. 템플릿에 컨텐츠 배포 슬롯이 없는 경우 마운트 된 엘리먼트의 기존 마크업은 무시됩니다.</p>
<p>문자열이 <code>#</code>로 시작하면 querySelector로 사용되며 선택된 엘리먼트의 innerHTML을 템플릿 문자열로 사용합니다. 이렇게 하면 일반적인 <code>&lt;script type=&quot;x-template&quot;&gt;</code> 트릭을 사용하여 템플릿을 포함할 수 있습니다.</p>
<p class="tip">보안 관점에서 신뢰할 수 있는 Vue 템플릿만 사용해야 합니다. 사용자 생성 콘텐츠를 템플릿으로 사용하면 안됩니다.</p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></li>
<li><a href="../guide/components.html#Content-Distribution-with-Slots">컨텐츠 배포</a></li>
</ul>
</li>
</ul>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>문자열 템플릿 대신 자바스크립트의 완전한 프로그래밍 기능을 활용할 수 있습니다. render 함수는 <code>VNode</code>를 생성하는데 사용되는 첫번째 인자인 <code>createElement</code> 메소드를 받습니다.</p>
<p>컴포넌트가 함수형 컴포넌트인 경우 렌더링 함수는 추가로 <code>context</code>를 인자로 받습니다. 이 것은 함수형 컴포넌트가 인스턴스가 없기 때문에 컨텍스트에 대한 액세스를 제공합니다.</p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/render-function">렌더 함수</a></li>
</ul>
</li>
</ul>
<h2 id="옵션-라이프사이클-훅"><a href="#옵션-라이프사이클-훅" class="headerlink" title="옵션 / 라이프사이클 훅"></a>옵션 / 라이프사이클 훅</h2><p>모든 라이프사이클 훅은 자동으로 <code>this</code> 컨텍스트를 인스턴스에 바인딩하므로 데이터, 계산된 속성 및 메소드에 접근할 수 있습니다. <strong>즉, 화살표 함수를 사용해 라이프사이클 메소드를 정의하면 안됩니다.(예: <code>created: () =&gt; this.fetchTodos()</code>)</strong> 이유는 화살표 함수가 부모 컨텍스트를 바인딩 하기 때문에 <code>this</code>는 예상대로 Vue 인스턴스가 아니며 <code>this.fetchTodos</code>는 정의되지 않습니다.</p>
<h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>인스턴스가 방금 초기화 된 후 데이터 관찰 및 이벤트 / 감시자 설정 전에 동기적으로 호출 됩니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></p>
</li>
</ul>
<h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>인스턴스가 작성된 후 동기적으로 호출됩니다. 이 단계에서 인스턴스는 데이터 처리, 계산된 속성, 메서드, 감시/이벤트 콜백 등과 같은 옵션 처리를 완료합니다. 그러나 마운트가 시작되지 않았으므로 <code>$el</code> 속성을 아직 사용할 수 없습니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></p>
</li>
</ul>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>마운트가 시작되기 바로 전에 호출됩니다. <code>render</code> 함수가 처음으로 호출 됩니다.</p>
<p><strong>이 훅은 서버측 렌더링 중 호출되지 않습니다</strong></p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></p>
</li>
</ul>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p><code>el</code>이 새로 생성된 <code>vm.$el</code>로 대체된 인스턴스가 마운트 된 직후 호출됩니다. 루트 인스턴스가 문서 내의 엘리먼트에 마운트 되어 있으면, <code>mounted</code>가 호출 될 때 <code>vm.$el</code>도 문서 안에 있게 됩니다.</p>
<p><strong>이 훅은 서버측 렌더링 중 호출되지 않습니다</strong></p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></p>
</li>
</ul>
<h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>가상 DOM이 다시 렌더링되고 패치 전 데이터가 변경되면 호출됩니다.<br>이 훅에서 더 많은 상태 변경을 수행할 수 있으며 추가로 재 렌더링을 트리거하지 않습니다.</p>
<p><strong>이 훅은 서버측 렌더링 중 호출되지 않습니다</strong></p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></p>
</li>
</ul>
<h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>데이터 변경 후 호출되어 가상 DOM이 다시 렌더링되고 패치 됩니다.</p>
<p>이 훅이 호출되면 엘리먼트의 DOM이 업데이트 된 상태가 되어 이 훅에서 DOM 종속적인 연산을 할 수 있습니다. 그러나 대부분의 경우 무한루프가 발생할 수 있으므로 훅에서 상태를 변경하면 안됩니다.</p>
<p><strong>이 훅은 서버측 렌더링 중 호출되지 않습니다</strong></p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></p>
</li>
</ul>
<h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>keep-alive 인 컴포넌트가 활성화 될 때 호출됩니다.</p>
<p><strong>이 훅은 서버측 렌더링 중 호출되지 않습니다</strong></p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="#keep-alive">내장 컴포넌트 - keep-alive</a></li>
<li><a href="../guide/components.html#keep-alive">동적 컴포넌트 - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>keep-alive인 컴포넌트가 비활성화 될 때 호출됩니다.</p>
<p><strong>이 훅은 서버측 렌더링 중 호출되지 않습니다</strong></p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="#keep-alive">내장 컴포넌트 - keep-alive</a></li>
<li><a href="../guide/components.html#keep-alive">동적 컴포넌트 - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스가 제거되기 전에 호출됩니다. 이 단계에서 인스턴스는 아직 완벽하게 작동합니다.</p>
<p><strong>이 훅은 서버측 렌더링 중 호출되지 않습니다</strong></p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></p>
</li>
</ul>
<h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><ul>
<li><p><strong>타입:</strong> <code>Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스가 제거된 후 호출됩니다. 이 훅이 호출되면 Vue 인스턴스의 모든 지시문이 바인딩 해제 되고 모든 이벤트 리스너가 제거되며 모든 하위 Vue 인스턴스도 삭제됩니다.</p>
<p><strong>이 훅은 서버측 렌더링 중 호출되지 않습니다</strong></p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></p>
</li>
</ul>
<h2 id="옵션-에셋"><a href="#옵션-에셋" class="headerlink" title="옵션 / 에셋"></a>옵션 / 에셋</h2><h3 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h3><ul>
<li><p><strong>타입:</strong> <code>Object</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스에서 사용할 수 있도록 만들어진 지시문의 해시</p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/custom-directive.html">사용자 정의 지시문</a></li>
<li><a href="../guide/components.html#Assets-Naming-Convention">에셋 네이밍 컨벤션</a></li>
</ul>
</li>
</ul>
<h3 id="filters"><a href="#filters" class="headerlink" title="filters"></a>filters</h3><ul>
<li><p><strong>타입:</strong> <code>Object</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스에서 사용할 수 있도록 만들어진 필터의 해시</p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="#Vue-filter"><code>Vue.filter</code></a></li>
</ul>
</li>
</ul>
<h3 id="components"><a href="#components" class="headerlink" title="components"></a>components</h3><ul>
<li><p><strong>타입:</strong> <code>Object</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스에서 사용할 수 있도록 만들어진 컴포넌트의 해시</p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/components.html">컴포넌트</a></li>
</ul>
</li>
</ul>
<h2 id="옵션-기타"><a href="#옵션-기타" class="headerlink" title="옵션 / 기타"></a>옵션 / 기타</h2><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><ul>
<li><p><strong>타입:</strong> <code>Vue instance</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>작성 할 인스턴스의 상위 인스턴스를 지정해야 합니다. 부모-자식 관계를 설정합니다. 부모는 자식에 대해 <code>this.$parent</code>로 접근할 수 있고 자식은 부모의 <code>$children</code>배열로 추가 됩니다.</p>
<p class="tip"><code>$parent</code>와 <code>$children</code>은 적당히 사용해야합니다. 대부분 escape-hatch로 사용합니다. 부모와 자식 간 의사소통은 props와 이벤트 사용을 권장합니다.</p>

</li>
</ul>
<h3 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h3><ul>
<li><p><strong>타입:</strong> <code>Array&lt;Object&gt;</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p><code>mixins</code> 옵션은 mixin 객체 배열을 받아들입니다. 이러한 mixin 객체는 일반 인스턴스 객체와 마찬가지로 인스턴스 옵션을 포함할 수 있으며, <code>Vue.extend()</code>에서 같은 옵션 병합 로직을 사용하여 최종 옵션과 병합됩니다. 예: mixin에 생성된 훅이 포함되어 있고 컴포넌트 자체에도 하나가 있으면 두 함수가 모두 호출 됩니다.</p>
<p>Mixin 훅은 제공된 순서대로 호출되며 컴포넌트의 훅보다 먼저 호출됩니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mixin = &#123;</div><div class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;,</div><div class="line">  <span class="attr">mixins</span>: [mixin]</div><div class="line">&#125;)</div><div class="line"><span class="comment">// -&gt; 1</span></div><div class="line"><span class="comment">// -&gt; 2</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/mixins.html">Mixins</a></p>
</li>
</ul>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><ul>
<li><p><strong>타입:</strong> <code>string</code></p>
</li>
<li><p><strong>제한:</strong> 컴포넌트 옵션으로 사용될 때만 사용할 수 있습니다.</p>
</li>
<li><p><strong>상세:</strong></p>
<p>컴포넌트가 템플릿을 반복적으로 자체 호출 할 수 있게 합니다. 컴포넌트가 <code>Vue.component()</code>로 전역으로 등록되면 전역 ID가 자동으로 이름으로 설정됩니다.</p>
<p><code>name</code> 옵션을 지정하는 또 다른 이점은 디버깅 입니다. 명명된 컴포넌트는 보다 유용한 경고 메시지를 만듭니다. 또한 <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="external">vue-devtools</a>에서 응용 프로그램을 살펴볼 때 익명의 컴포넌트는 매우 유용하지 않은 <code>&lt;AnonymousComponent&gt;</code>로 표시됩니다. <code>name</code> 옵션을 제공함으로써 훨씬 더 쓸모있는 컴포넌트 트리를 얻을 수 있습니다.</p>
</li>
</ul>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><ul>
<li><p><strong>타입:</strong> <code>Object | Function</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p><code>Vue.extend</code>를 사용하지 않고 선언적으로 다른 컴포넌트를 확장할 수 있습니다. (일반 옵션 객체 또는 생성자 일 수 있습니다.) 이것은 주로 단일 파일 컴포넌트 사이를 쉽게 확장할 수 있도록 하기 위함입니다.</p>
<p>이것은 <code>mixins</code>와 유사합니다. 차이점은 컴포넌트의 자체 옵션이 확장되는 원본 컴포넌트보다 우선순위가 높다는 것 입니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> CompA = &#123; ... &#125;</div><div class="line"></div><div class="line"><span class="comment">// Vue.extend를 호출하지 않고도 CompA를 확장할 수 있습니다.</span></div><div class="line"><span class="keyword">var</span> CompB = &#123;</div><div class="line">  <span class="attr">extends</span>: CompA,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="delimiters"><a href="#delimiters" class="headerlink" title="delimiters"></a>delimiters</h3><ul>
<li><p><strong>타입:</strong> <code>Array&lt;string&gt;</code></p>
</li>
<li><p><strong>기본값:</strong> <code>["{{", "}}"]</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>일반 텍스트 보간 구분 기호를 변경하십시오. <strong>이 옵션은 독립 실행형 빌드에서만 사용할 수 있습니다. </strong></p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">delimiters</span>: [<span class="string">'$&#123;'</span>, <span class="string">'&#125;'</span>]</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 구분 기호가 ES6 템플릿 문자열 스타일로 변경되었습니다.</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="functional"><a href="#functional" class="headerlink" title="functional"></a>functional</h3><ul>
<li><p><strong>타입:</strong> <code>boolean</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>컴포넌트에 상태를 저장하지 않는(<code>data</code>가 없음) 및 인스턴스가 없도록 (<code>this</code> 컨텍스트가 없음) 만듭니다. 단순히 가상 노드를 반환하는 <code>render</code> 함수로 렌더링을 훨씬 더 가볍게 만듭니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/render-function.html#Functional-Components">Functional Components</a></p>
</li>
</ul>
<h2 id="인스턴스-속성"><a href="#인스턴스-속성" class="headerlink" title="인스턴스 속성"></a>인스턴스 속성</h2><h3 id="vm-data"><a href="#vm-data" class="headerlink" title="vm.$data"></a>vm.$data</h3><ul>
<li><p><strong>타입:</strong> <code>Object</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스가 관찰하는 데이터 객체입니다. Vue 인스턴스는 데이터 객체의 속성에 대한 엑세스를 프록시 합니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="#data">옵션 - data</a></p>
</li>
</ul>
<h3 id="vm-el"><a href="#vm-el" class="headerlink" title="vm.$el"></a>vm.$el</h3><ul>
<li><p><strong>타입:</strong> <code>HTMLElement</code></p>
</li>
<li><p><strong>읽기 전용</strong></p>
</li>
<li><p><strong>상세:</strong></p>
<p>Vue 인스턴스가 관리하는 루트 DOM 엘리먼트 입니다.</p>
</li>
</ul>
<h3 id="vm-options"><a href="#vm-options" class="headerlink" title="vm.$options"></a>vm.$options</h3><ul>
<li><p><strong>타입:</strong> <code>Object</code></p>
</li>
<li><p><strong>읽기 전용</strong></p>
</li>
<li><p><strong>상세:</strong></p>
<p>인스턴스화 옵션은 현재 Vue 인스턴스에 사용됩니다. 이 옵션은 옵션에 사용자 정의 속성을 포함해야할 경우 유용합니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">customOption</span>: <span class="string">'foo'</span>,</div><div class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.customOption) <span class="comment">// -&gt; 'foo'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="vm-parent"><a href="#vm-parent" class="headerlink" title="vm.$parent"></a>vm.$parent</h3><ul>
<li><p><strong>타입:</strong> <code>Vue instance</code></p>
</li>
<li><p><strong>읽기 전용</strong></p>
</li>
<li><p><strong>상세:</strong></p>
<p>현재 인스턴스에 부모 인스턴스가 있는 경우, 부모 인스턴스 입니다.</p>
</li>
</ul>
<h3 id="vm-root"><a href="#vm-root" class="headerlink" title="vm.$root"></a>vm.$root</h3><ul>
<li><p><strong>타입:</strong> <code>Vue instance</code></p>
</li>
<li><p><strong>읽기 전용</strong></p>
</li>
<li><p><strong>상세:</strong></p>
<p>현재 컴포넌트 트리의 루트 Vue 인스턴스입니다. 현재 인스턴스에 부모가 없으면 이 값이 그 자체로 사용됩니다.</p>
<h3 id="vm-children"><a href="#vm-children" class="headerlink" title="vm.$children"></a>vm.$children</h3></li>
<li><p><strong>타입:</strong> <code>Array&lt;Vue instance&gt;</code></p>
</li>
<li><p><strong>읽기 전용</strong></p>
</li>
<li><p><strong>상세:</strong></p>
<p> 현재 인스턴스가 가지고 있는 바로 하위의 컴포넌트 입니다. <strong><code>$children</code>에 대한 순서 보장은 없으며, 반응형이 아닙니다.</strong> 데이터 바인딩을 위해 <code>$children</code>을 사용하려면, Array와 <code>v-for</code>를 사용하여 자식 컴포넌트를 생성하는 것을 고려하세요. Array를 원본으로 사용하세요.</p>
</li>
</ul>
<h3 id="vm-slots"><a href="#vm-slots" class="headerlink" title="vm.$slots"></a>vm.$slots</h3><ul>
<li><p><strong>타입:</strong> <code>{ [name: string]: ?Array&lt;VNode&gt; }</code></p>
</li>
<li><p><strong>읽기 전용</strong></p>
</li>
<li><p><strong>상세:</strong></p>
<p>프로그래밍으로 접근 가능한 컨텐트 <a href="../guide/components.html#Content-Distribution-with-Slots">슬롯 별 배포</a>에 사용합니다. 각 <a href="../guide/components.html#Named-Slots">명명된 슬롯</a>은 고유한 속성을 가지고 있습니다. (예: <code>slot=foo</code> 는 <code>vm.$slots.foo</code>에서 찾을 수 있습니다.) <code>default</code> 속성은 명명된 슬롯에 포함되지 않은 노드를 포함합니다.</p>
<p><code>vm.$slots</code>에 접근하는 것은 <a href="../guide/render-function.html">렌더 함수</a>로 컴포넌트를 작성할 때 가장 유용합니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">blog-post</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span></div><div class="line">    About Me</div><div class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span></div><div class="line">    Copyright 2016 Evan You</div><div class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class="tag">&lt;/<span class="name">p</span>&gt;</span>.</div><div class="line"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> header = <span class="keyword">this</span>.$slots.header</div><div class="line">    <span class="keyword">var</span> body   = <span class="keyword">this</span>.$slots.default</div><div class="line">    <span class="keyword">var</span> footer = <span class="keyword">this</span>.$slots.footer</div><div class="line">    <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</div><div class="line">      createElement(<span class="string">'header'</span>, header),</div><div class="line">      createElement(<span class="string">'main'</span>, body),</div><div class="line">      createElement(<span class="string">'footer'</span>, footer)</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="#slot-1"><code>&lt;slot&gt;</code> 컴포넌트</a></li>
<li><a href="../guide/components.html#Content-Distribution-with-Slots">Slot을 이용한 컨텐트 배포</a></li>
<li><a href="../guide/render-function.html#Slots">렌더 함수: Slots</a></li>
</ul>
</li>
</ul>
<h3 id="vm-scopedSlots"><a href="#vm-scopedSlots" class="headerlink" title="vm.$scopedSlots"></a>vm.$scopedSlots</h3><blockquote>
<p>2.1.0의 새로운 기능</p>
</blockquote>
<ul>
<li><p><strong>타입:</strong> <code>{ [name: string]: props =&gt; VNode | Array&lt;VNode&gt; }</code></p>
</li>
<li><p><strong>읽기 전용</strong></p>
</li>
<li><p><strong>상세:</strong></p>
<p><a href="../guide/components.html#Scoped-Slots">범위가 지정된 슬롯</a>에 프로그래밍으로 액세스하는데 사용됩니다. <code>default</code>를 포함하여 각 슬롯에 대해 객체는 VNode를 반환하는 해당 함수를 포함합니다.</p>
<p><code>vm.$scopedSlots</code>에 접근하는 것은 <a href="../guide/render-function.html">렌더 함수</a>로 컴포넌트를 작성할 때 가장 유용합니다.</p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="#slot-1"><code>&lt;slot&gt;</code> 컴포넌트</a></li>
<li><a href="../guide/components.html#Scoped-Slots">범위가 지정된 슬롯</a></li>
<li><a href="../guide/render-function.html#Slots">렌더 함수: Slots</a></li>
</ul>
</li>
</ul>
<h3 id="vm-refs"><a href="#vm-refs" class="headerlink" title="vm.$refs"></a>vm.$refs</h3><ul>
<li><p><strong>타입:</strong> <code>Object</code></p>
</li>
<li><p><strong>읽기 전용</strong></p>
</li>
<li><p><strong>상세:</strong></p>
<p><code>ref</code>가 등록된 자식 컴포넌트를 보관하는 객체입니다.</p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/components.html#Child-Component-Refs">자식 컴포넌트 참조</a></li>
<li><a href="#ref">ref</a></li>
</ul>
</li>
</ul>
<h3 id="vm-isServer"><a href="#vm-isServer" class="headerlink" title="vm.$isServer"></a>vm.$isServer</h3><ul>
<li><p><strong>타입:</strong> <code>boolean</code></p>
</li>
<li><p><strong>읽기 전용</strong></p>
</li>
<li><p><strong>상세:</strong></p>
<p>현재 Vue 인스턴스가 서버에서 실행중인지 여부.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/ssr.html">서버측 렌더링</a></p>
</li>
</ul>
<h2 id="인스턴스-메소드-데이터"><a href="#인스턴스-메소드-데이터" class="headerlink" title="인스턴스 메소드 / 데이터"></a>인스턴스 메소드 / 데이터</h2><h3 id="vm-watch">vm.$watch( expOrFn, callback, [options] )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{string | Function} expOrFn</code></li>
<li><code>{Function} callback</code></li>
<li><code>{Object} [options]</code><ul>
<li><code>{boolean} deep</code></li>
<li><code>{boolean} immediate</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>반환 값:</strong> <code>{Function} unwatch</code></p>
</li>
<li><p><strong>사용방법:</strong></p>
<p>변경을 위해 Vue 인스턴스에서 표현식이나 계산된 함수를 감시합니다. 콜백은 새 값과 이전 값을 인자로 호출됩니다. 표현식은 점으로 구분된 경로를 허용합니다. 더 복잡한 표현식을 사용하려면 함수를 사용하세요.</p>
<p class="tip">참고: Object 또는 Array를 변경하는 대신 변형하는 경우 동일한 Object / Array를 참조하므로 이전 값은 새 값과 같습니다. Vue는 사전 변이된 값의 사본을 보관하지 않습니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// keypath</span></div><div class="line">vm.$watch(<span class="string">'a.b.c'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</div><div class="line">  <span class="comment">// 필요한 코드를 작성하세요</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// function</span></div><div class="line">vm.$watch(</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</div><div class="line">    <span class="comment">// 필요한 코드를 작성하세요</span></div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p><code>vm.$watch</code>는 콜백을 호출하지 않는 unwatch 함수를 반환합니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> unwatch = vm.$watch(<span class="string">'a'</span>, cb)</div><div class="line"><span class="comment">// 나중에, 감시자를 제거해야합니다</span></div><div class="line">unwatch()</div></pre></td></tr></table></figure>
</li>
<li><p><strong>옵션: deep</strong></p>
</li>
</ul>
<p>  Objects 내부의 중첩된 값 변경을 감지하려면 options 인자에 <code>deep: true</code>를 전달해야 합니다. Array 변이를 수신하기 위해 그렇게 할 필요는 없습니다.</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><div class="line">vm.$watch(<span class="string">'someObject'</span>, callback, &#123;</div><div class="line">  <span class="attr">deep</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line">vm.someObject.nestedValue = <span class="number">123</span></div><div class="line"><span class="comment">// 콜백이 호출됩니다</span></div></pre></td></tr></table></figure>
<ul>
<li><p><strong>옵션: immediate</strong></p>
<p>옵션에서 <code>immediate: true</code>를 전달하면 표현식의 현재 값으로 즉시 콜백을 호출합니다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">vm.$watch(<span class="string">'a'</span>, callback, &#123;</div><div class="line">  <span class="attr">immediate</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 콜백은`a`의 현재 값으로 즉시 시작됩니다.</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="vm-set">vm.$set( object, key, value )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{Object} object</code></li>
<li><code>{string} key</code></li>
<li><code>{any} value</code></li>
</ul>
</li>
<li><p><strong>반환 값:</strong> 설정된 값</p>
</li>
<li><p><strong>사용방법:</strong></p>
<p>전역 <code>Vue.set</code>의 <strong>별칭</strong> 입니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="#Vue-set">Vue.set</a></p>
</li>
</ul>
<h3 id="vm-delete">vm.$delete( object, key )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{Object} object</code></li>
<li><code>{string} key</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>전역 <code>Vue.delete</code>의 <strong>별칭</strong> 입니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="#Vue-delete">Vue.delete</a></p>
</li>
</ul>
<h2 id="인스턴스-메소드-이벤트"><a href="#인스턴스-메소드-이벤트" class="headerlink" title="인스턴스 메소드 / 이벤트"></a>인스턴스 메소드 / 이벤트</h2><h3 id="vm-on">vm.$on( event, callback )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{string} event</code></li>
<li><code>{Function} callback</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>현재 VM에서 사용자 정의 이벤트를 듣습니다. 이벤트는 <code>vm.$emit</code>에 의해 호출될 수 있습니다. 콜백은 이러한 이벤트 트리거 메소드에 전달 된 모든 추가 인수를 수신합니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">vm.$on(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(msg)</div><div class="line">&#125;)</div><div class="line">vm.$emit(<span class="string">'test'</span>, <span class="string">'hi'</span>)</div><div class="line"><span class="comment">// -&gt; "hi"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="vm-once">vm.$once( event, callback )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{string} event</code></li>
<li><code>{Function} callback</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>사용자 이벤트를 한번만 듣습니다. 리스너는 한번 호출되면 제거됩니다.</p>
</li>
</ul>
<h3 id="vm-off">vm.$off( [event, callback] )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{string} [event]</code></li>
<li><code>{Function} [callback]</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>이벤트 리스너를 제거합니다.</p>
<ul>
<li>인자가 없으면 모든 이벤트 리스너를 제거합니다.</li>
<li>이벤트만 인자로 전달 받는 경우 해당 이벤트의 모든 리스너를 제거합니다.</li>
<li>이벤트와 콜백을 전달 받으면 특정 콜백에 대한 리스너만 제거합니다.</li>
</ul>
</li>
</ul>
<h3 id="vm-emit">vm.$emit( event, […args] )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{string} event</code></li>
<li><code>[...args]</code></li>
</ul>
<p>현재 인스턴스에서 이벤트를 트리거 합니다. 추가 인자는 리스너의 콜백 함수로 전달됩니다ㅣ.</p>
</li>
</ul>
<h2 id="인스턴스-메소드-라이프사이클"><a href="#인스턴스-메소드-라이프사이클" class="headerlink" title="인스턴스 메소드 / 라이프사이클"></a>인스턴스 메소드 / 라이프사이클</h2><h3 id="vm-mount">vm.$mount( [elementOrSelector] )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{Element | string} [elementOrSelector]</code></li>
<li><code>{boolean} [hydrating]</code></li>
</ul>
</li>
<li><p><strong>반환 값:</strong> <code>vm</code> - 인스턴스 그 자체</p>
</li>
<li><p><strong>사용방법:</strong></p>
<p>Vue 인스턴스가 인스턴스화 할 때 <code>el</code> 옵션이 없으면 연결된 DOM 엘리먼트 없이 “unmounted” 상태가 됩니다. <code>vm.$mount()</code>는 unmounted 된 Vue인스턴스의 마운트를 수동으로 시작하는데 사용할 수 있습니다.</p>
<p><code>elementOrSelector</code> 인자가 제공되지 않으면, 템플릿은 문서가 아닌 엘리먼트로 렌더링 될 것이므로 DOM API를 사용하여 문서에 직접 삽입해야 합니다.</p>
<p>이 메소드는 다른 인스턴스 메소드를 체이닝 할 수 있도록 인스턴스 그 자체를 반환 합니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;div&gt;Hello!&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 생성하고 #app에 마운트 합니다.(#app을 대체합니다)</span></div><div class="line"><span class="keyword">new</span> MyComponent().$mount(<span class="string">'#app'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 위와 같습니다.</span></div><div class="line"><span class="keyword">new</span> MyComponent(&#123; <span class="attr">el</span>: <span class="string">'#app'</span> &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 또는 문서를 렌더링하고 나중에 추가할 수 있습니다.</span></div><div class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> MyComponent().$mount()</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).appendChild(component.$el)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></li>
<li><a href="../guide/ssr.html">서버측 렌더링</a></li>
</ul>
</li>
</ul>
<h3 id="vm-forceUpdate">vm.$forceUpdate()</h3>

<ul>
<li><p><strong>사용방법:</strong></p>
<p>Vue 인스턴스를 강제로 다시 렌더링합니다. 모든 하위 컴포넌트에는 영향이 미치지 않으며, 슬롯 그 자체가 삽입된 슬롯 자체 및 하위 컴포넌트에만 영향을 미칩니다.</p>
</li>
</ul>
<h3 id="vm-nextTick">vm.$nextTick( [callback] )</h3>

<ul>
<li><p><strong>전달인자:</strong></p>
<ul>
<li><code>{Function} [callback]</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>다음 DOM 업데이트 사이클 이후 실행될 콜백을 연기합니다. DOM 업데이트를 기다리기 위해 일부 데이터를 변경한 직후 사용하십시오. 이 것은 콜백의 <code>this</code>컨텍스트가 이 메소드를 호출하는 인스턴스에 자동으로 바인딩되는 점을 제외하고 전역 <code>Vue.nextTick</code>과 같습니다.</p>
<blockquote>
<p>2.1.0의 새로운 기능 : 콜백이 제공되지 않고 Promise가 실행 환경에서 지원되는 경우 Promise를 반환합니다.</p>
</blockquote>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  methods: &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    example: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// 데이터 수정</span></div><div class="line">      <span class="keyword">this</span>.message = <span class="string">'changed'</span></div><div class="line">      <span class="comment">// 아직 DOM 이 갱신되지 않음</span></div><div class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// DOM이 이제 갱신됨</span></div><div class="line">        <span class="comment">// `this` 가 현재 인스턴스에 바인딩 됨</span></div><div class="line">        <span class="keyword">this</span>.doSomethingElse()</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="#Vue-nextTick">Vue.nextTick</a></li>
<li><a href="../guide/reactivity.html#Async-Update-Queue">비동기 업데이트 큐</a></li>
</ul>
</li>
</ul>
<h3 id="vm-destroy">vm.$destroy()</h3>

<ul>
<li><p><strong>사용방법:</strong></p>
<p>vm을 완전히 제거합니다. 다른 기존 VM과의 연결을 정리하고 모든 지시문을 바인딩 해제하고 모든 이벤트 리스너를 제거합니다.</p>
<p><code>beforeDestroy</code>와 <code>destroyed</code> 훅을 호출합니다.</p>
<p class="tip">일반적인 사용에서는 이 메소드를 직접 호출하면 안됩니다. <code>v-if</code>와 <code>v-for</code>를 사용하여 데이터 기반 방식으로 하위 컴포넌트의 라이프사이클을 제어하는 것이 좋습니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/instance.html#Lifecycle-Diagram">라이프사이클 다이어그램</a></p>
</li>
</ul>
<h2 id="지시문"><a href="#지시문" class="headerlink" title="지시문"></a>지시문</h2><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ul>
<li><p><strong>예상됨:</strong> <code>string</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>엘리먼트의 <code>textContent</code>를 업데이트 합니다. <code>textContent</code>의 일부를 갱신해야 하면 <code>{{ Mustache }}</code>를 사용해야 합니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 같습니다 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/syntax.html#Text">데이터 바인딩 문법 - 보간</a></p>
</li>
</ul>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ul>
<li><p><strong>예상됨:</strong> <code>string</code></p>
</li>
<li><p><strong>상세:</strong></p>
<p>엘리먼트의 <code>innerHTML</code>을 업데이트 합니다. <strong>내용은 일반 HTML으로 삽입되므로 Vue 템플릿으로 컴파일 되지 않습니다.</strong> <code>v-html</code>을 사용하여 템플릿을 작성하려는 경우 컴포넌트를 사용하여 솔루션을 다시 생각해 보십시오.</p>
<p class="tip">  웹사이트에서 임의의 HTML을 동적으로 렌더링하면 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="external">XSS 공격</a>으로 이어질 수 있으므로 매우 위험할 수 있습니다. 신뢰할 수 있는 컨텐츠에만 <code>v-html</code>을 사용하고 사용자가 제공한 컨텐츠에는 <strong>절대로</strong> 사용하지 마십시오</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"html"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/syntax.html#Raw-HTML">데이터 바인딩 문법 - 보간</a></p>
</li>
</ul>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><ul>
<li><p><strong>예상됨:</strong> <code>any</code></p>
</li>
<li><p><strong>사용방법:</strong></p>
<p>토글은 표현식 값의 참에 기반한 <code>display</code> CSS 속성입니다.</p>
<p>이 지시문은 조건이 바뀌면 전환이 호출 됩니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/conditional.html#v-show">조건부 렌더링 - v-show</a></p>
</li>
</ul>
<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><ul>
<li><p><strong>예상됨:</strong> <code>any</code></p>
</li>
<li><p><strong>사용방법:</strong></p>
<p>표현식 값의 참 거짓을 기반으로 엘리먼트를 조건부 렌더링 합니다. 엘리먼트 및 포함된 지시문 / 컴포넌트는 토글하는 동안 삭제되고 다시 작성됩니다. 엘리먼트가 <code>&lt;template&gt;</code>엘리먼트인 경우 그 내용은 조건부 블록이 됩니다.</p>
<p>조건이 변경될 때 전환이 호출 됩니다.</p>
</li>
</ul>
<p class="tip">v-if와 함께 사용하는 경우, v-for는  v-if보다 높은 우선순위를 갖습니다. 자세한 내용은 <a href="../guide/list.html#v-for-with-v-if">리스트 렌더링 가이드</a>를 확인하십시오.</p>

<ul>
<li><strong>참고:</strong> <a href="../guide/conditional.html">조건부 렌더링 - v-if</a></li>
</ul>
<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><ul>
<li><p><strong>표현식이 필요 없습니다.</strong></p>
</li>
<li><p><strong>제한:</strong> 이전 형제 엘리먼트가 <code>v-if</code>또는 <code>v-else-if</code>이어야 합니다.</p>
</li>
<li><p><strong>사용방법:</strong></p>
<p><code>v-if</code> 또는<code>v-if</code> /<code>v-else-if</code> 체인을위한 “else 블록”을 나타냅니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span></div><div class="line">  Now you see me</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></div><div class="line">  Now you don't</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/conditional.html#v-else">조건부 렌더링 - v-else</a></li>
</ul>
</li>
</ul>
<h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><blockquote>
<p>2.1.0의 새로운 기능</p>
</blockquote>
<ul>
<li><p><strong>예상됨:</strong> <code>any</code></p>
</li>
<li><p><strong>제한:</strong> 이전 형제 엘리먼트가 <code>v-if</code> 또는 <code>v-else-if</code> 이어야 합니다.</p>
</li>
<li><p><strong>사용방법:</strong></p>
</li>
</ul>
<p>  <code>v-if</code>에 대한 “else if 블록”을 나타냅니다. 체이닝 가능합니다.</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></div><div class="line">  A</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></div><div class="line">  B</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></div><div class="line">  C</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></div><div class="line">  Not A/B/C</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>참고:</strong> <a href="../guide/conditional.html#v-else-if">조건부 렌더링 - v-else-if</a></li>
</ul>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ul>
<li><p><strong>예상됨:</strong> <code>Array | Object | number | string</code></p>
</li>
<li><p><strong>사용방법:</strong></p>
<p>원본 데이터를 기반으로 엘리먼트 또는 템플릿 블록을 여러번 렌더링합니다. 지시문의 값은 반복되는 현재 엘리먼트에 대한 별칭을 제공하기 위해 특수 구문인 <code>alias in expression</code>을 사용해야 합니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></div><div class="line">  &#123;&#123; item.text &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>또는, 인덱스(아니면 객체의 경우 키)의 별칭을 지정할 수 있습니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(val, key) in object"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(val, key, index) in object"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>v-for</code>의 기본 동작은 엘리먼트를 이동하지 않고 그 자리에서 패치를 시도합니다. 강제로 엘리먼트의 순서를 바꾸려면 특수 속성 <code>key</code>를 설정해야 합니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></div><div class="line">  &#123;&#123; item.text &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p class="tip">v-if와 함께 사용하는 경우, v-for는  v-if보다 높은 우선순위를 갖습니다. 자세한 내용은 <a href="../guide/list.html#v-for-with-v-if">리스트 렌더링 가이드</a>를 확인하십시오.</p>

<p><code>v-for</code>에 대한 자세한 사용법은 아래 링크된 가이드에서 설명합니다.</p>
<ul>
<li><strong>참고:</strong><ul>
<li><a href="../guide/list.html">리스트 렌더링</a></li>
<li><a href="../guide/list.html#key">key</a></li>
</ul>
</li>
</ul>
<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul>
<li><p><strong>약어:</strong> <code>@</code></p>
</li>
<li><p><strong>예상됨:</strong> <code>Function | Inline Statement</code></p>
</li>
<li><p><strong>전달인자:</strong> <code>event (required)</code></p>
</li>
<li><p><strong>수식어:</strong></p>
<ul>
<li><code>.stop</code> - <code>event.stopPropagation()</code> 을 호출합니다.</li>
<li><code>.prevent</code> - <code>event.preventDefault()</code> 을 호출합니다.</li>
<li><code>.capture</code> - 캡처 모드에서 이벤트 리스너를 추가합니다.</li>
<li><code>.self</code> - 이벤트가 이 엘리먼트에서 전달된 경우에만 처리 됩니다</li>
<li><code>.{keyCode | keyAlias}</code> - 특정 키에 대해서만 처리 됩니다.</li>
<li><code>.native</code> - 컴포넌트의 루트 엘리먼트에서 네이티브 이벤트를 수신합니다.</li>
<li><code>.once</code> - 단 한번만 처리됩니다.</li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>엘리먼트에 이벤트 리스너를 연결합니다. 이벤트 유형은 전달인자로 표시됩니다. 표현식은 메소드 이름 또는 인라인 구문일 수 있으며, 수식어가 있으면 생략할 수 있습니다.</p>
<p>일반 엘리먼트에 사용되면 <strong>기본 DOM 이벤트</strong>만 받습니다. 사용자 정의 컴포넌트에서 사용될 떄 해당 하위 컴포넌트에서 생성된 <strong>사용자 정의 이벤트</strong>를 받습니다.</p>
<p>네이티브 DOM 이벤트를 수신하면 메소드는 네이티브 이벤트를 유일한 전달인자로 받습니다. 인라인 구문을 사용하는 경우 명령문은 특별한 <code>$event</code> 속성에 접근할 수 있습니다: <code>v-on: click = &quot;handle(&#39;ok&#39;, $event)&quot;</code></p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 메소드 핸들러 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 인라인 구문 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"doThat('hello', $event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 약어 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 전파 금지 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 기본 동작 방지 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 표현식이 없는 기본 동작 방지 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 수식어 체이닝 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop.prevent</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 키 별칭을 이용한 키 입력 수식어 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"onEnter"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 키 코드를 이용한 키 입력 수식어 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.13</span>=<span class="string">"onEnter"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- the click event will be triggered at most once --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>하위 컴포넌트에서 사용자 지정 이벤트를 수신합니다. (자식에서 “my-event”가 생성될 때 처리기가 호출 됩니다.)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">my-event</span>=<span class="string">"handleThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 인라인 구문 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">my-event</span>=<span class="string">"handleThis(123, $event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 컴포넌트의 기본 이벤트 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">click.native</span>=<span class="string">"onClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/events.html">메소드와 이벤트 핸들링</a></li>
<li><a href="../guide/components.html#Custom-Events">컴포넌트 - 사용자 정의 이벤트</a></li>
</ul>
</li>
</ul>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul>
<li><p><strong>약어:</strong> <code>:</code></p>
</li>
<li><p><strong>예상됨:</strong> <code>any (with argument) | Object (without argument)</code></p>
</li>
<li><p><strong>전달인자:</strong> <code>attrOrProp (optional)</code></p>
</li>
<li><p><strong>수식어:</strong></p>
<ul>
<li><code>.prop</code> - 속성 대신 DOM 속성으로 바인딩 (<a href="http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028" target="_blank" rel="external">무슨 차이가 있습니까?</a>)</li>
<li><code>.camel</code> - kebab-case 속성 이름을 camelCase로 변환합니다. (2.1.0이후 지원)</li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>동적으로 하나 이상의 컴포넌트 속성 또는 표현식을 바인딩 합니다.</p>
<p><code>class</code>또는 <code>style</code> 속성을 묶는 데 사용될 때, Array나 Objects와 같은 추가 값 유형을 지원합니다. 자세한 내용은 아래 링크된 섹션을 참조하십시오.</p>
<p>속성 바인딩에 사용할 때 속성은 하위 컴포넌트에서 올바르게 선언되어야 합니다.</p>
<p>전달인자 없이 사용하면 속성 이름 - 값 쌍을 포함하는 객체를 바인딩 하는데 사용할 수 있습니다. 이 모드에서는 <code>class</code>와 <code>style</code>은 Array나 Objects를 지원하지 않습니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 속성을 바인딩 합니다. --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"imageSrc"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 약어 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"imageSrc"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- with inline string concatenation --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"'/path/to/images/' + fileName"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 클래스 바인딩 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123; red: isRed &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, classB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, &#123; classB: isB, classC: isC &#125;]"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 스타일 바인딩 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; fontSize: size + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"[styleObjectA, styleObjectB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 속성 객체 바인딩 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">"&#123; id: someProp, 'other-attr': otherProp &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- prop 수식어를 사용하는 DOM 속성 바인딩 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:text-content.prop</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 속성 바인딩. 컴포넌트에서 "prop"를 선언 해야 합니다.  --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">:prop</span>=<span class="string">"someThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- XLink --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">:xlink:special</span>=<span class="string">"foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>.camel</code> 수식어는 DOM 템플릿을 사용할 떄 <code>v-bind</code> 속성 이름을 camelCase화 할수 있습니다. (예: SVG <code>viewBox</code>속성)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">:view-box.camel</span>=<span class="string">"viewBox"</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure>
<p>문자열 템플릿을 사용하거나 <code>vue-loader</code>/<code>vueify</code> 로 컴파일 하는 경우 <code>.camel</code>은 필요 없습니다.</p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/class-and-style.html">클래스 및 스타일 바인딩</a></li>
<li><a href="../guide/components.html#Props">컴포넌트 - 컴포넌트 속성</a></li>
</ul>
</li>
</ul>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul>
<li><p><strong>예상됨:</strong> 컴포넌트 폼 인풋 엘리먼트 또는 출력 값에 따라 다릅니다.</p>
</li>
<li><p><strong>제한사항:</strong></p>
<ul>
<li><code>&lt;input&gt;</code></li>
<li><code>&lt;select&gt;</code></li>
<li><code>&lt;textarea&gt;</code></li>
<li>components</li>
</ul>
</li>
<li><p><strong>수식어:</strong></p>
<ul>
<li><a href="../guide/forms.html#lazy"><code>.lazy</code></a> - <code>input</code>대신 <code>change</code> 이벤트를 듣습니다.</li>
<li><a href="../guide/forms.html#number"><code>.number</code></a> - 문자열을 숫자로 변경합니다.</li>
<li><a href="../guide/forms.html#trim"><code>.trim</code></a> - 입력에 대한 trim 을 합니다.</li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>폼 인풋 엘리먼트 또는 컴포넌트에 양방향 바인딩을 만듭니다. 자세한 사용법은 아래 링크된 가이드 섹션을 참조하십시오.</p>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/forms.html">폼 인풋 바인딩</a></li>
<li><a href="../guide/components.html#Form-Input-Components-using-Custom-Events">컴포넌트 - 사용자 정의 이벤트를 이용하는 폼 인풋 컴포넌트</a></li>
</ul>
</li>
</ul>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul>
<li><p><strong>표현식이 필요하지 않습니다</strong></p>
</li>
<li><p><strong>사용방법:</strong></p>
<p>이 엘리먼트와 모든 자식 엘리먼트에 대한 컴파일을 건너 뜁니다. 원시 mustache 태그를 표시하는데 사용할 수 있습니다. 지시문이 없는 많은 수의 노드를 뛰어 넘으면 컴파일 속도가 빨라집니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123; 이 부분은 컴파일 되지 않습니다 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><ul>
<li><p><strong>표현식이 필요하지 않습니다</strong></p>
</li>
<li><p><strong>사용방법:</strong></p>
<p>이 지시문은 Vue 인스턴스가 컴파일을 완료할 때까지 엘리먼트에 남아있습니다. <code>[v-cloak] { display: none }</code>와 같은 CSS규칙과 함께 이 지시문은 Vue인스턴스가 준비될 때까지 컴파일되지 않은 mustache 바인딩을 숨기는데 사용할 수 있습니다.</p>
</li>
<li><p><strong>예제:</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-attr">[v-cloak]</span> &#123;</div><div class="line">  <span class="attribute">display</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span></div><div class="line">  &#123;&#123; message &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>&lt;div&gt;</code>는 컴파일이 끝날 때까지 보이지 않습니다.</p>
</li>
</ul>
<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><ul>
<li><p><strong>표현식이 필요하지 않습니다</strong></p>
</li>
<li><p><strong>상세:</strong></p>
<p>엘리먼트 및 컴포넌트를 <strong>한번만</strong> 렌더링 합니다. 후속 렌더링에서 엘리먼트 / 컴포넌트와 모든 하위 엘리먼트는 정적으로 처리되어 건너 뜁니다. 이는 업데이트 성능을 최적화하는데 사용합니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 단일 엘리먼트 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 자식 엘리먼트를 포함하는 엘리먼트 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 컴포넌트 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-once</span> <span class="attr">:comment</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- v-for 지시문 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"i in list"</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong></p>
<ul>
<li><a href="../guide/syntax.html#Text">데이터 바인딩 문법 - 보간</a></li>
<li><a href="../guide/components.html#Cheap-Static-Components-with-v-once">컴포넌트 - v-once를 이용한 가벼운 정적 컴포넌트</a></li>
</ul>
</li>
</ul>
<h2 id="특별한-속성들"><a href="#특별한-속성들" class="headerlink" title="특별한 속성들"></a>특별한 속성들</h2><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><ul>
<li><p><strong>예상됨:</strong> <code>string</code></p>
<p><code>key</code> 특수 속성은 Vue의 가상 DOM 알고리즘이 새로운 노드 목록을 이전 목록과 비교할 때 VNode를 식별하기 위한 힌트로 주로 사용됩니다. 키가 없으면 Vue는 엘리먼트 이동을 최소화하고 같은 유형의 엘리먼트를 최대한 많이 패치 / 재사용하려고 하는 알고리즘을 사용합니다. 키를 사용하면 키의 순서 변경을 기반으로 엘리먼트가 재정렬되고 더 이상 존재하지 않는 키가 있는 엘리먼트는 항상 제거 / 삭제 됩니다.</p>
<p>동일한 부모의 자식 엘리먼트는 <strong>고유 키</strong> 가 있어야 합니다. 키가 중복되면 렌더링 오류가 발생합니다.</p>
<p>가장 일반적인 이용 사례는 <code>v-for</code>와 결합합니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>엘리먼트 / 컴포넌트를 재사용하지 않고 강제로 대체하는데에도 사용할 수 있습니다. 이것은 다음과 같은 경우 유용할 수 있습니다.</p>
<ul>
<li>컴포넌트의 라이프사이클 훅을 올바르게 트리거합니다.</li>
<li>전환효과 호출</li>
</ul>
<p>For example:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">"text"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure>
<p>When <code>text</code> changes, the <code>&lt;span&gt;</code> will always be replaced instead of patched, so a transition will be triggered.</p>
</li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul>
<li><p><strong>예상됨:</strong> <code>string</code></p>
<p><code>ref</code> 엘리먼트 또는 자식 컴포넌트에 대한 참조를 등록하는데 사용합니다. 참조는 부모 컴포넌트의 <code>$refs</code> 객체 아래에 등록됩니다. 일반 DOM 엘리먼트에서 사용되는 경우 참조는 해당 엘리먼트입니다. 하위 컴포넌트에서 사용되는 경우 참조는 컴포넌트 인스턴스 입니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- vm.$refs.p는 DOM 노드가 됩니다 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">"p"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- vm.$refs.child는 자식 컴포넌트 인스턴스가 됩니다. --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">child-comp</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-comp</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>v-for</code>를 사용하여 엘리먼트 / 컴포넌트에 사용되는 경우 등록된 참조는 DOM 노드 또는 컴포넌트 인스턴스가 포함된 배열입니다.</p>
<p>참조 등록 타이밍에 대한 중요한 참고 사항: 참조 자체는 렌더링 함수의 결과로 생서되기 떄문에 초기 렌더링에서 참조 자체를 액세스 할 수 없습니다. 아직 존재하지 않습니다! <code>$refs</code>는 또한 반응이 없으므로 데이터 바인딩을 위해 템플릿에서 사용해서는 안됩니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/components.html#Child-Component-Refs">자식 컴포넌트 참조</a></p>
</li>
</ul>
<h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><ul>
<li><p><strong>예상됨:</strong> <code>string</code></p>
<p>컨텐츠가 있는 슬롯의 이름을 위해 자식 컴포넌트에 삽입된 컨텐츠에 사용됩니다.</p>
<p>자세한 사용법은 아래 링크 된 가이드 섹션을 참조하십시오.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/components.html#Named-Slots">명명된 슬롯</a></p>
</li>
</ul>
<h2 id="내장-컴포넌트"><a href="#내장-컴포넌트" class="headerlink" title="내장 컴포넌트"></a>내장 컴포넌트</h2><h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>
<li><code>inline-template</code> - boolean</li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>동적 컴포넌트 렌더링을 위한 “메타 컴포넌트”입니다. 렌더링할 실제 컴포넌트는 <code>is</code> prop에 의해 결정됩니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">&lt;!-- vm 의 `componentId` 속성에 의해   --&gt;</span></div><div class="line"><span class="comment">&lt;!-- 제어되는 동적 컴포넌트 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"componentId"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 등록된 컴포넌트 또는 컴포넌트를 prop로 전달할 수 있습니다. --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"$options.components.child"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/components.html#Dynamic-Components">동적 컴포넌트</a></p>
</li>
</ul>
<h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>name</code> - string, 전환 CSS 클래스 이름을 자동으로 생성하는데 사용됩니다. 예: <code>name: &#39;fade&#39;</code>는 자동으로 <code>.fade-enter</code>, <code>.fade-enter-active</code>로 확장됩니다. 기본값은 <code>&quot;v&quot;</code>입니다.</li>
<li><code>appear</code> - boolean, 초기 렌더링에서 전환 적용 여부를 정합니다. 기본값은 <code>false</code> 입니다.</li>
<li><code>css</code> - boolean, CSS 전환 클래스를 적용할 여부입니다. 기본 값은 <code>true</code>입니다. <code>false</code>로 설정하면 컴포넌트 이벤트를 통해 등록된 자바스크립트 훅만 호출됩니다.</li>
<li><code>type</code> - string, 전환 종료 타이밍을 결정하기 위해 대기할 전환 이벤트의 유형을 지정합니다. 사용 가능한 값은 <code>&quot;transition&quot;</code>과 <code>&quot;animation&quot;</code>입니다. 기본적으로 더 긴 지속시간을 갖는 유형을 자동으로 감지합니다.</li>
<li><code>mode</code> - string, Controls the timing sequence of leaving/entering transitions. Available modes are <code>&quot;out-in&quot;</code> and <code>&quot;in-out&quot;</code>; defaults to simultaneous.</li>
<li><code>mode</code> - string, 트랜지션을 나가거나 들어가는 타이밍 순서를 제어합니다. 사용 가능한 모드는 <code>&quot;out-in&quot;</code>과 <code>&quot;in-out&quot;</code>입니다. 기본값은 동시에 발생합니다.</li>
<li><code>enter-class</code> - string</li>
<li><code>leave-class</code> - string</li>
<li><code>enter-active-class</code> - string</li>
<li><code>leave-active-class</code> - string</li>
<li><code>appear-class</code> - string</li>
<li><code>appear-active-class</code> - string</li>
</ul>
</li>
<li><p><strong>이벤트:</strong></p>
<ul>
<li><code>before-enter</code></li>
<li><code>enter</code></li>
<li><code>after-enter</code></li>
<li><code>before-leave</code></li>
<li><code>leave</code></li>
<li><code>after-leave</code></li>
<li><code>before-appear</code></li>
<li><code>appear</code></li>
<li><code>after-appear</code></li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p><code>&lt;transition&gt;</code>은 <strong>단일</strong> 엘리먼트 / 컴포넌트에 대한 전환 효과로 사용됩니다. <code>&lt;transition&gt;</code>은 추가 DOM 엘리먼트를 렌더링 하지 않으며 컴포넌트 계층에도 나타나지 않습니다. 내부의 래핑된 컨텐츠에 단순히 전환 효과를 적용합니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 단일 엘리먼트 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span>toggled content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 동적 컴포넌트 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span> <span class="attr">appear</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 이벤트 훅 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"transition-demo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span> @<span class="attr">after-enter</span>=<span class="string">"transitionComplete"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span>toggled content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  ...</div><div class="line">  methods: &#123;</div><div class="line">    <span class="attr">transitionComplete</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">      <span class="comment">// 전달된 'el'에 대해 DOM 엘리먼트를 전달인자로 사용하는 경우..</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;).$mount(<span class="string">'#transition-demo'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/transitions.html">Transitions: 진입, 진출, 그리고 리스트</a></p>
</li>
</ul>
<h3 id="transition-group"><a href="#transition-group" class="headerlink" title="transition-group"></a>transition-group</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>tag</code> - string, 기본값은 <code>span</code> 입니다.</li>
<li><code>move-class</code> - 이동 전환 중에 적용된 CSS클래스를 덮어 씁니다.</li>
<li><code>mode</code>를 제외한 <code>&lt;transition&gt;</code>과 동일한 prop를 노출합니다.</li>
</ul>
</li>
<li><p><strong>이벤트:</strong></p>
<ul>
<li><code>&lt;transition&gt;</code>과 같은 이벤트를 노출합니다.</li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p><code>&lt;transition-group&gt;</code>은 <strong>여러</strong> 엘리먼트 / 컴포넌트에 대한 전환 효과로 사용합니다. <code>&lt;transition-group&gt;</code>은 실제 DOM 엘리먼트를 렌더링 합니다. 기본값으로 <code>&lt;span&gt;</code>을 렌더링하고 <code>tag</code> 속성을 통해 렌더링 해야하는 엘리먼트를 설정할 수 있습니다.<br>애니메이션이 제대로 작동되게 하려면 <code>&lt;transition-group&gt;</code>에 있는 모든 자식이 <strong>유일 키</strong> 가 되어야 합니다.</p>
<p><code>&lt;transition-group&gt;</code>은 CSS transform을 통해 장면 전환을 지원합니다. 스크린에서 자식의 위치가 변경된 후 움직이는 CSS클래스 (<code>name</code> 속성에서 자동 생성되거나 <code>move-class</code> 속성으로 설정됨)가 적용됩니다. 움직이는 클래스가 적용될 때 CSS <code>transform</code> 속성이 “전환가능”하면, 엘리먼트는 <a href="https://aerotwist.com/blog/flip-your-animations/" target="_blank" rel="external">FLIP technique</a>을 사용하여 목적지로 부드럽게 움직입니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">tag</span>=<span class="string">"ul"</span> <span class="attr">name</span>=<span class="string">"slide"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></div><div class="line">    &#123;&#123; item.text &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>참고:</strong> <a href="../guide/transitions.html">Transitions: 진입, 진출, 그리고 리스트</a></p>
</li>
</ul>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>include</code> - string or RegExp. 일치하는 컴퍼넌트만 캐시됩니다.</li>
<li><code>exclude</code> - string or RegExp. 일치하는 컴퍼넌트는 캐시되지 않습니다.</li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p>동적 컴포넌트를 감싸는 경우 <code>&lt;keep-alive&gt;</code>는 비활성 컴포넌트 인스턴스를 파괴하지 않고 캐시합니다. <code>&lt;transition&gt;</code>과 비슷하게 <code>&lt;keep-alive&gt;</code>는 추상 엘리먼트입니다. DOM 엘리먼트 자체는 렌더링 하지 않고 컴포넌트 부모 체인에는 나타나지 않습니다.</p>
<p>컴포넌트가 <code>&lt;keep-alive&gt;</code>내에서 토글 될 때, <code>activated</code>와 <code>deactivated</code>라이프사이클 훅이 그에 따라 호출됩니다.</p>
<p>주로 컴포넌트 상태를 보존하거나 재 렌더링을 피하는데 사용합니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 기본 사용 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 여러개의 조건부 자식 컴포넌트 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">comp-a</span> <span class="attr">v-if</span>=<span class="string">"a &gt; 1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp-a</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">comp-b</span> <span class="attr">v-else</span>&gt;</span><span class="tag">&lt;/<span class="name">comp-b</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- &lt;transition&gt;과 함께 사용합니다. --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong><code>include</code> 와 <code>exclude</code></strong></p>
<blockquote>
<p>2.1.0의 새로운 기능</p>
</blockquote>
<p><code>include</code>와<code>exclude</code> prop는 컴포넌트를 조건부 캐시 할 수 있습니다. 두 prop는 쉼표로 분리 된 문자열이거나 RegExp 입니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 콤마로 구분된 문자열 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"a,b"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- regex (v-bind 사용) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"/a|b/"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>name</code> 옵션을 사용할 수없는 경우, 컴포넌트 자신의<code>name</code> 옵션에서 일치하는 항목을 먼저 확인한 다음 로컬 등록 이름 (부모의<code>components</code> 옵션에서 키)을 확인합니다. 익명의 컴포넌트는 일치시킬 수 없습니다.</p>
<p class="tip"><code>&lt;keep-alive&gt;</code>는 캐시 될 인스턴스가 없으므로 함수형 컴포넌트에서 작동하지 않습니다.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/components.html#keep-alive">동적 컴포넌트 - keep-alive</a></p>
</li>
</ul>
<h3 id="slot-1"><a href="#slot-1" class="headerlink" title="slot"></a>slot</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>name</code> - string, 명명된 슬롯으로 사용합니다</li>
</ul>
</li>
<li><p><strong>사용방법:</strong></p>
<p><code>&lt;slot&gt;</code> 은 컴포넌트 템플릿의 컨텐츠 배포 역할을 합니다. <code>&lt;slot&gt;</code>은 대체됩니다</p>
<p>자세한 사용법은 아래 링크된 가이드 섹션을 참조하십시오.</p>
</li>
<li><p><strong>참고:</strong> <a href="../guide/components.html#Content-Distribution-with-Slots">Slot을 이용한 컨텐트 배포</a></p>
</li>
</ul>
<h2 id="VNode-인터페이스"><a href="#VNode-인터페이스" class="headerlink" title="VNode 인터페이스"></a>VNode 인터페이스</h2><ul>
<li><a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js" target="_blank" rel="external">VNode class declaration</a>를 참조하십시오.</li>
</ul>
<h2 id="서버측-렌더링"><a href="#서버측-렌더링" class="headerlink" title="서버측 렌더링"></a>서버측 렌더링</h2><ul>
<li><a href="https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer" target="_blank" rel="external">vue-server-renderer 패키지 문서</a>를 참조하십시오.</li>
</ul>

    
    <div class="footer">
      이 문서에 문제를 제보하거나 기여하고 싶은 부분이 있으십니까?
      <a href="https://github.com/vuejs-kr/kr.vuejs.org/blob/master/src/v2/api/index.md" target="_blank">
        Github에서 이 페이지를 수정하세요!
      </a>
    </div>
</div>

                
            </div>
            <script src="/js/smooth-scroll.min.js"></script>
        

        <!-- main custom script for sidebars, version selects etc. -->
        <script src="/js/common.js"></script>

        <!-- ga -->
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-89623208-1', 'vuejs.org');
          ga('send', 'pageview');
        </script>

        <!-- search -->
        <link href="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="/css/search.css">
        <script src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
        <script>
        [
          '#search-query-nav',
          '#search-query-sidebar'
        ].forEach(function (selector) {
          if (!document.querySelector(selector)) return
          // search index defaults to v2
          var match = window.location.pathname.match(/^\/(v\d+)/)
          var version = match ? match[1] : 'v2'
          docsearch({
            appId: 'BH4D9OD16A',
            apiKey: '6d4ed4990adfc74c08d2f69f21c000d6',
            indexName: 'vuejs_kr',
            inputSelector: selector,
            algoliaOptions: { facetFilters: ["version:" + version] }
          })
        })
        </script>

        <!-- fastclick -->
        <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
        <script>
        document.addEventListener('DOMContentLoaded', function() {
          FastClick.attach(document.body)
        }, false)
        </script>
    </body>
</html>
